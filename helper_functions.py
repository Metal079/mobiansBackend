import io
import base64
import logging
import random

from PIL import Image, ImageDraw, ImageFont, PngImagePlugin


# ---- image manipulation -----

# Create the watermark image and font objects outside the function
watermark_text = "Mobians.ai"
opacity = 128
font_file_path = r"fonts/Roboto-Medium.ttf"
font = ImageFont.truetype(font_file_path, 25)


# async def remove_alpha_channel(image):
#     # Convert image to RGB if it has an alpha channel
#     if image.mode == "RGBA":
#         buffer = io.BytesIO()
#         # Separate alpha channel and add white background
#         background = Image.new("RGBA", image.size, (255, 255, 255))
#         alpha_composite = Image.alpha_composite(background, image).convert("RGB")
#         alpha_composite.save(buffer, format="PNG")
#         return alpha_composite
#     else:
#         return image


async def add_image_metadata(image, request_data, lossy_image=False):
    img_io = io.BytesIO()
    image_with_watermark = await add_watermark(image)

    metadata = PngImagePlugin.PngInfo()
    metadata_dict = {
        "model": f"Mobians.ai / {request_data['model']}",
        "Disclaimer": "The image is generated by Mobians.ai. The image is not real and is generated by an AI.",
    }

    try:
        if request_data['job_type'] != "txt2img":
            metadata_dict["NOTE"] = (
                "The image was not generated purely using txt2img, using the info below may not give you the same results."
            )

        metadata_dict["prompt"] = request_data['prompt']
        metadata_dict["negative_prompt"] = request_data['negative_prompt']
        metadata_dict["seed"] = str(request_data['seed'])
        metadata_dict["cfg"] = str(request_data['guidance_scale'])
        metadata_dict["job_type"] = request_data['job_type']
        metadata_dict["loras"] = []
        for lora in request_data['loras']:
            metadata_dict["loras"].append(lora['name'] + " - " + lora['version'] + " - " + 'strength: ' + str(lora['strength']))

        # Convert list to string
        metadata_dict["loras"] = '\n'.join(metadata_dict["loras"])
    except Exception as e:
        logging.error(f"Error adding metadata to image: {e}")
        with open("error_log.txt", "a") as f:
            f.write(f"Error adding metadata to image: {request_data}\n")

    for key, value in metadata_dict.items():
        metadata.add_text(key, value)

    if lossy_image:
        image_with_watermark.save(img_io, format="webp", quality=95, lossless=False, pnginfo=metadata)
    else:
        image_with_watermark.save(img_io, format="PNG", pnginfo=metadata)
    img_io.seek(0)
    base64_image = base64.b64encode(img_io.getvalue()).decode("utf-8")
    return base64_image


async def add_watermark(image):
    # Calculate image dimensions
    image_width, image_height = image.size
    
    # Calculate font size as a percentage of image width
    font_size = int(image_width * 0.05)  # 5% of the image width
    font_size = max(font_size, 10)  # Ensure a minimum font size
    font = ImageFont.truetype(font_file_path, font_size)
    
    # Create a new watermark layer
    watermark = Image.new("RGBA", image.size, (255, 255, 255, 0))
    draw = ImageDraw.Draw(watermark)
    
    # Calculate position margins as a percentage of image dimensions
    margin_x = int(image_width * 0.02)  # 1% margin from the left
    margin_y = int(image_height * 0.01)  # 1% margin from the top
    
    # Adjust stroke width based on font size
    stroke_width = max(2, int(font_size / 20))
    
    # Draw text with stroke for better visibility
    for dx in range(-stroke_width, stroke_width + 1):
        for dy in range(-stroke_width, stroke_width + 1):
            draw.text(
                (margin_x + dx, margin_y + dy),
                watermark_text,
                font=font,
                fill=(0, 0, 0, opacity)
            )
    
    # Draw the main watermark text
    draw.text(
        (margin_x, margin_y),
        watermark_text,
        font=font,
        fill=(255, 255, 255, opacity)
    )
    
    # Combine the watermark with the original image
    image_with_watermark = Image.alpha_composite(image.convert("RGBA"), watermark)
    return image_with_watermark
