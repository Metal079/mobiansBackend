import io
import base64
import logging
import random
import time
import math
from typing import Optional, Dict

from PIL import Image, ImageDraw, ImageFont, PngImagePlugin


# ---- image manipulation -----

# Create the watermark image and font objects outside the function
watermark_text = "Mobians.ai"
opacity = 128
font_file_path = r"fonts/Roboto-Medium.ttf"
font = ImageFont.truetype(font_file_path, 25)


# async def remove_alpha_channel(image):
#     # Convert image to RGB if it has an alpha channel
#     if image.mode == "RGBA":
#         buffer = io.BytesIO()
#         # Separate alpha channel and add white background
#         background = Image.new("RGBA", image.size, (255, 255, 255))
#         alpha_composite = Image.alpha_composite(background, image).convert("RGB")
#         alpha_composite.save(buffer, format="PNG")
#         return alpha_composite
#     else:
#         return image


async def add_image_metadata(image, request_data, lossy_image=False):
    img_io = io.BytesIO()
    image_with_watermark = await add_watermark(image)

    metadata = PngImagePlugin.PngInfo()
    metadata_dict = {
        "model": f"Mobians.ai / {request_data['model']}",
        "Disclaimer": "The image is generated by Mobians.ai. The image is not real and is generated by an AI.",
    }

    try:
        if request_data['job_type'] != "txt2img":
            metadata_dict["NOTE"] = (
                "The image was not generated purely using txt2img, using the info below may not give you the same results."
            )

        metadata_dict["prompt"] = request_data['prompt']
        metadata_dict["negative_prompt"] = request_data['negative_prompt']
        metadata_dict["seed"] = str(request_data['seed'])
        metadata_dict["cfg"] = str(request_data['guidance_scale'])
        metadata_dict["job_type"] = request_data['job_type']
        metadata_dict["loras"] = []
        for lora in request_data['loras']:
            metadata_dict["loras"].append(lora['name'] + " - " + lora['version'] + " - " + 'strength: ' + str(lora['strength']))

        # Convert list to string
        metadata_dict["loras"] = '\n'.join(metadata_dict["loras"])
    except Exception as e:
        logging.error(f"Error adding metadata to image: {e}")
        with open("error_log.txt", "a") as f:
            f.write(f"Error adding metadata to image: {request_data}\n")

    for key, value in metadata_dict.items():
        metadata.add_text(key, value)

    if lossy_image:
        image_with_watermark.save(img_io, format="webp", quality=95, lossless=False, pnginfo=metadata)
    else:
        image_with_watermark.save(img_io, format="PNG", pnginfo=metadata)
    img_io.seek(0)
    base64_image = base64.b64encode(img_io.getvalue()).decode("utf-8")
    return base64_image


async def add_watermark(image):
    # Calculate image dimensions
    image_width, image_height = image.size
    
    # Calculate font size as a percentage of image width
    font_size = int(image_width * 0.05)  # 5% of the image width
    font_size = max(font_size, 10)  # Ensure a minimum font size
    font = ImageFont.truetype(font_file_path, font_size)
    
    # Create a new watermark layer
    watermark = Image.new("RGBA", image.size, (255, 255, 255, 0))
    draw = ImageDraw.Draw(watermark)
    
    # Calculate position margins as a percentage of image dimensions
    margin_x = int(image_width * 0.02)  # 1% margin from the left
    margin_y = int(image_height * 0.01)  # 1% margin from the top
    
    # Adjust stroke width based on font size
    stroke_width = max(2, int(font_size / 20))
    
    # Draw text with stroke for better visibility
    for dx in range(-stroke_width, stroke_width + 1):
        for dy in range(-stroke_width, stroke_width + 1):
            draw.text(
                (margin_x + dx, margin_y + dy),
                watermark_text,
                font=font,
                fill=(0, 0, 0, opacity)
            )
    
    # Draw the main watermark text
    draw.text(
        (margin_x, margin_y),
        watermark_text,
        font=font,
        fill=(255, 255, 255, opacity)
    )
    
    # Combine the watermark with the original image
    image_with_watermark = Image.alpha_composite(image.convert("RGBA"), watermark)
    return image_with_watermark


# ---- throughput/ETA helpers -----
THROUGHPUT_CACHE_TTL_SEC = 30  # refresh at most every 30s
EWMA_ALPHA = 0.6  # smoothing factor for rate updates
throughput_cache: Dict[str, Optional[float]] = {"last_refresh": None, "jobs_per_sec": None}


async def refresh_throughput_cache(db_pool) -> float:
    """Refresh cached jobs/sec using DB function public.get_last_10_minutes_total_completed()."""
    count_last_10_min = 0
    try:
        async with db_pool.connection() as aconn:
            async with aconn.cursor() as acur:
                await acur.execute("SELECT public.get_last_10_minutes_total_completed();")
                row = await acur.fetchone()
                if row is not None and row[0] is not None:
                    count_last_10_min = float(row[0])
    except Exception as e:
        logging.error(f"Failed to refresh throughput cache: {e}")

    window_seconds = 600.0
    raw_rate = (count_last_10_min / window_seconds) if window_seconds > 0 else 0.0

    prev = throughput_cache.get("jobs_per_sec") or 0.0
    # Apply EWMA smoothing; avoid snapping to zero immediately when there is a lull
    if raw_rate == 0.0 and prev > 0.0:
        smoothed = prev * 0.95  # gentle decay when no jobs completed in window
    else:
        smoothed = EWMA_ALPHA * raw_rate + (1.0 - EWMA_ALPHA) * prev

    smoothed = max(smoothed, 0.0)
    throughput_cache["jobs_per_sec"] = smoothed
    throughput_cache["last_refresh"] = time.time()
    return smoothed


async def get_jobs_per_sec(db_pool) -> float:
    """Return cached jobs/sec, refreshing if TTL expired."""
    last = throughput_cache.get("last_refresh")
    if last is None or (time.time() - last) > THROUGHPUT_CACHE_TTL_SEC:
        rate = await refresh_throughput_cache(db_pool)
    else:
        rate = throughput_cache.get("jobs_per_sec") or 0.0
    return rate


def compute_eta_seconds(queue_position: Optional[int], jobs_per_sec: float) -> Optional[int]:
    if queue_position is None:
        return None
    if jobs_per_sec <= 0:
        return None
    return int(math.ceil(max(queue_position, 0) / jobs_per_sec))
